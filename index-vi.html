<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Node.js cho người mới bắt đầu » Tài liệu hướng dẫn toàn diện về Node.js</title>
        <meta name="description" content="Một tài liệu hướng dẫn toàn diện cho người mới bắt đầu: Học cách xây dựng ứng dụng web sử dụng "server-side" Javascript" />
        
        <link rel="icon" href="favicon.png" type="image/png" />
        <link rel="stylesheet" type="text/css" href="default.css" />
    </head>
    <body>
        <div id="ibookstore-banner">
            <a href="buy-ibook/index.html"><img src="ibookstore-banner.jpg" width="100%" /></a>
        </div>

        <div id="translations">
            <table>
                <tr>
                    <td>
                        <a href="index-jp.html">
                            <div class="flag"><img src="jp-flag.png" width="24" height="24" alt="japanese flag" /></div>
                            <div class="text">日本語で読む</div>
                        </a>
                    </td>
                    <td>
                        <a href="index-es.html">
                            <div class="flag"><img src="es-flag.png" width="24" height="24" alt="spanish flag" /></div>
                            <div class="text">Lee este tutorial en Español</div>
                        </a>
                    </td>
                    <td>
                        <a href="index-kr.html">
                            <div class="flag"><img src="kr-flag.png" width="24" height="24" alt="korean flag" /></div>
                            <div class="text">이 튜토리얼을 한글로 보세요</div>
                        </a>
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="index-zh-cn.html">
                            <div class="flag"><img src="cn-flag.png" width="24" height="24" alt="chinese flag" /></div>
                            <div class="text">阅读本书中文版</div>
                        </a>
                    </td>
                    <td>
                        <a href="index-zh-tw.html">
                            <div class="flag"><img src="cn-flag.png" width="24" height="24" alt="chinese flag" /></div>
                            <div class="text">阅读本书繁体中文版</div>
                        </a>
                    </td>
                    <td>
                        <a href="http://www.nodebeginner.ru">
                            <div class="flag"><img src="ru-flag.png" width="24" height="24" alt="russian flag" /></div>
                            <div class="text">Читать этот учебник на русском</div>
                        </a>
                    </td>
                </tr>
            </table>
        </div>

        <div class="buybox">
            <div class="buy-the-bundle">
                <div class="cover">
                    <p>
                        The perfect introduction plus the perfect reference in one bundle!
                    </p>
                    <a href="buy-bundle/index.html"><img src="the_node_beginner_book_cover_small.png" height="86" width="57" /></a>
                    <a href="buy-bundle/index.html"><img src="hands-on_node.js_cover.png" height="86" width="57" /></a>
                </div>
                <div class="description">
                    <p>
                        LeanBundle currently offers<br />
                        the final version of
                        <br />
                        <strong>The Node Beginner Book</strong>
                        <br />
                        plus Pedro Teixeira's excellent
                        <br />
                        <strong>Hands-on Node.js</strong> for only
                        <br />
                        <br />
                        <strong class="price dollarsign">$</strong><strong class="price">9.99</strong>
                        <br />
                        (regular price <del>$21.98</del>)
                    </p>
                </div>
                <div class="buy">
                    <p>
                        226 pages in total
                        <br />
                        PDF, ePub & MOBI
                        <br />
                        Direct download
                        <br />
                        Free updates
                    </p>
                    <a class="buttonlink" href="buy-bundle/index.html">
                        <div class="button">Buy this<br />bundle now</div>
                    </a>
                </div>
            </div>
        </div>


        <div id="book">
        <div>
        <h1>Node.js cho người mới bắt đầu</h1>

        <div id="author">Một tài liệu hướng dẫn về Node.js bởi <a href="http://twitter.com/manuelkiessling">Manuel Kiessling</a></div>

        <a name="about"></a>

        <h2>Giới thiệu</h2>

        <p>
            Tài liệu này hướng tới mục tiêu giúp bạn bắt đầu phát triển các ứng dụng sử dụng Node.js và dạy cho bạn tất cả những thứ bạn cần biết về Javascript "nâng cao", vượt xa ứng dụng "Hello World" điển hình.
        </p>

        <a name="status"></a>

        <h3>Tình trạng</h3>

        <p>
            Bạn đang đọc phiên bản mới nhất của cuốn sách này, điều này có nghĩa là các cập nhật chỉ được thực hiện để phù hợp với các thay đổi cũng như các bản sửa lỗi của các phiên bản Node.js mới. Lần cập nhập mới nhất được thực hiện vào 01 tháng 07 năm 2013.
        </p>

        <p>
            Mã nguồn các ví dụ trong cuốn sách này đã được kiểm tra và xác nhận hoạt động tốt với phiên bản Node.js 0.10.12.
        </p>

        <p>
            Trang web này cho phép bạn đọc miễn phí từ trang 1 tới trang 21 của cuốn sách. Phiên bản đầy đủ được cung cấp miễn phí dưới dạng DRM-free eBook (PDF, ePub, và định dạng cho Kindle). Xem thêm thông tin phía cuối trang.
        </p>

        <a name="intended-audience"></a>

        <h3>Đối tượng độc giả</h3>

        <p>
            Tài liệu này chắc chắn phù hợp với độc giả có kiến thức tương tự như tôi: đã có kinh nghiệm với ít nhất một ngôn ngữ lập trình hướng đối tượng như Ruby, Python, PHP hay Java, một chút kinh nghiệm về Javascript và hoàn toàn lạ lẫm với Node.js.
        </p>

        <p>
            Hướng tới các lập trình viên đã có kinh nghiệm với các ngôn ngữ lập trình khác đồng nghĩa với việc cuốn sách này sẽ không đề cập tới những phạm trù cơ bản tương tự như kiểu dữ liệu, biến, các cấu trúc điều khiển v.v. Để hiểu tốt hơn về cuốn sách này, bạn cần nắm vững những vấn đề cơ bản trên.
        </p>

        <p>
            Tuy nhiên, các hàm và đối tượng trong JavaScript khác biệt so với các ngôn ngữ khác, nên nó sẽ được giải thích chi tiết hơn.
        </p>

        <a name="structure"></a>

        <h3>Cấu trúc</h3>

        <p>
            Hoàn thành tài liệu này cũng đồng nghĩa với việc bạn đã xây dựng hoàn chỉnh một ứng dụng web có khả năng cho phép người dùng duyệt qua các trang khác nhau và tải file lên.
        </p>

        <p>
            Tất nhiên, đây không hẳn là thứ mang tính chất thay đổi thế giới, nhưng chúng ta sẽ tiến xa hơn việc chỉ làm các ví dụ bằng việc xây dựng một framework có các thành phần được tổ chức, bố trí rõ ràng. Bạn sẽ được thấy nó trong ít phút nữa.
        </p>

        <p>
            Chúng ta sẽ bắt đầu bằng việc phân tích sự khác nhau trong quá trình phát triển của JavaScript trong Node.js và trình duyệt.
        </p>

        <p>
            Tiếp đó, chúng ta sẽ trở lại với ứng dụng "Hello World" truyền thống, ứng dụng Node.js cơ bản nhất.
        </p>

        <p>
            Sau đó chúng ta sẽ thảo luận về một ứng dụng thực tế mà chúng ta muốn xây dựng, phân tích kỹ lưỡng các thành phần khác nhau cần xây dựng của ứng dụng, và bắt tay lần lượt từng bước vào mỗi phần.
        </p>

        <p>
            Như đã đề cập trước, song song đó chúng ta sẽ học một số khái niệm nâng cao về JavaScript, học cách áp dụng chúng vào trong ứng dụng của chúng ta, và cùng nghiên cứu tại sao việc áp dụng các khái niệm đó lại tốt hơn những khái niệm tương tự chúng ta đã biết trong các ngôn ngữ lập trình khác.
        </p>

        <p>
            Mã nguồn hoàn thiện của ứng dụng có thể tải về tại địa chỉ 
            <a href="https://github.com/ManuelKiessling/NodeBeginnerBook/tree/master/code/application">the
                NodeBeginnerBook Github repository</a>.
        </p>

        <div id="table-of-contents-headline">Mục lục</div>
        <div id="table-of-contents">
            <ul>

                <li><a href="#about">Giới thiệu</a>
                    <ul>
                        <li><a href="#status">Trạng thái</a></li>
                        <li><a href="#intended-audience">Đối tượng độc giả</a></li>
                        <li><a href="#structure">Cấu trúc</a></li>
                    </ul>
                </li>

                <li><a href="#javascript-and-nodejs">JavaScript và Node.js</a>
                    <ul>
                        <li><a href="#javascript-and-you">JavaScript và Bạn</a></li>
                        <li><a href="#a-word-of-warning">Đôi lời nhắc nhở</a></li>
                        <li><a href="#server-side-javascript">Server-side JavaScript</a></li>
                        <li><a href="#hello-world">"Hello World"</a></li>

                    </ul>
                </li>
                <li><a href="#a-full-blown-web-application-with-nodejs">Một ứng dụng web hoàn thiện với Node.js</a>
                    <ul>
                        <li><a href="#the-use-cases">The use cases</a></li>
                        <li><a href="#the-application-stack">Cấu trúc ứng dụng</a></li>
                    </ul>

                </li>
                <li><a href="#building-the-application-stack">Xây dựng cấu trúc của ứng dụng</a>
                    <ul>
                        <li><a href="#a-basic-http-server">Một máy chủ HTTP đơn giản</a></li>
                        <li><a href="#analyzing-our-http-server">Phân tích máy chủ HTTP</a></li>
                        <li><a href="#passing-functions-around">Sự tương tác giữa các hàm</a></li>
                        <li><a href="#how-function-passing-makes-our-http-server-work">Sử dụng hàm như biến</a></li>

                        <li><a href="#event-driven-callbacks">Gọi lại không đồng bộ dựa trên sự kiện</a></li>
                        <li><a href="#how-our-server-handles-requests">Máy chủ xử lý yêu cầu như thế nào</a></li>
                        <li><a href="#finding-a-place-for-our-server-module">Nơi lưu trữ "module" của máy chủ</a>
                        </li>
                        <li><a href="#whats-needed-to-route-requests">"Điều hướng" yêu cầu cần những gì?</a></li>
                        <li><a href="#execution-in-the-kongdom-of-verbs">"Sự thực hiện"</a></li>
                        <li><a href="#routing-to-real-request-handlers">Điều hướng tới "nơi xử lý" yêu cầu thật</a></li>

                        <li><strong>Các chương chỉ có trong sách:</strong>
                            <li>Làm cho các "bộ xử lý yêu cầu" (request handlers) trả lời
                                <ul>
                                    <li>How to not do it</li>
                                    <li>Blocking and non-blocking</li>
                                    <li>Responding request handlers with non-blocking operation</li>
                                </ul>
                            </li>
                            <li>Serving something useful
                                <ul>
                                    <li>Handling POST requests</li>
                                    <li>Handling file uploads</li>
                                </ul>
                            </li>
                            <li>Conclusion and outlook</li>
                        </li>
                    </ul>
                </li>
            </ul>
        </div>

        <a name="javascript-and-nodejs"></a>

        <h2>JavaScript và Node.js</h2>

        <a name="javascript-and-you"></a>

        <h3>JavaScript và Bạn</h3>

        <p>
            Trước khi đề cập đến các vấn đề mang tính kỹ thuật, hãy dành một chút thời gian để nói về chính bạn và mối quan hệ của bạn với JavaScript. Sự hiện diện của chương này cho phép bạn có thể tự đánh giá được khả năng hiểu/lĩnh hội các nội dung tiếp theo.
        </p>

        <p>
            Nếu bạn giống tôi, bạn bắt đầu với "lập trình" HTML trước đây, bằng việc viết các tài liệu HTML. Bạn tiếp cận với một thứ khôi hài có tên JavaScript, nhưng bạn chỉ sử dụng nó ở mức độ hết sức cơ bản, nâng cao tính tương tác cho các trang web của bạn từ trước tới nay.
        </p>

        <p>
            Cái mà bạn thật sự muốn là "cái gì đó mang tính thực tế", bạn muốn biết làm thế nào để xây dựng những website phức tạp - bạn học một ngôn ngữ lập trình chẳng hạn như PHP, Ruby, Java, và bắt đầu viết "backend" code. (Có thể hiểu là phần mã nguồn thực chạy trên máy chủ - server, không phải mã HTML).
        </p>

        <p>
            Tuy nhiên, bạn lại quan tâm đến JavaScript, bạn thấy chúng qua các giới thiệu về jQuery, Prototype, hay tương tự..., mọi thứ về JavaScript trở nên cao cấp hơn, và nó thực sự phức tạp hơn là <em>window.open</em>.
        </p>

        <p>
            Mặc dù vậy, tất cả vẫn chỉ dừng lại ở phía frontend (thực thi trên trình duyệt), và mặc dù thật là tốt khi có jQuery để sử dụng mỗi khi bạn muốn thêm chút "gia vị" cho trang web của bạn, suy cho cùng, ở cái mức độ tốt nhất, thì bạn chỉ là một <em>người dùng</em> JavaScript chứ không phải một <em>lập trình viên</em> JavaScript.
        </p>

        <p>
            Và Node.js xuất hiện. JavaScript chạy phía máy chủ, thật tuyệt phải không?
        </p>

        <p>
            Bạn quyết định sớm muộn gì cũng phải tìm hiểu về cái JavaScript cũ, mới đó. Nhưng đừng vội, viết ứng dụng Node.js là một chuyện, hiểu được tại sao nó lại được viết như vậy mới gọi là - hiểu JavaScript. Và lần này mới là thực tế.
        </p>

        <p>
            Đây là vấn đề của chúng ta: Bởi vì JavaScript thực sự có đến hai, thậm chí 3 loại khác nhau (cái DHTML helper nho nhỏ, vui vui từ giữa những năm 90, đến các thư viện phía client/máy khách như jQuery, và bây giờ là phía máy chủ), không dễ dàng gì để tìm tài liệu giúp bạn học JavaScript đúng cách, để viết các ứng dụng sử dụng Node.js tạm ổn để bạn không cảm thấy giống như đang <em>sử dụng</em> JavaScript mà là đang <em>phát triển</em> nó.
        </p>

        <p>
            Bởi vì đó là cách để bạn nắm bắt nó: bạn đã là một lập trình viên có kinh nghiệm, bạn không muốn học một kỹ thuật mới chỉ bằng việc mổ xẻ lung tung hay dùng nó không đúng cách; bạn muốn chắc chắn rằng bạn đang tiếp cận nó từ một góc nhìn đúng đắn.
        </p>

        <p>
            Tuy rằng luôn có các tài liệu tham khảo chính thức rất đầy đủ tồn tại. Nhưng chỉ tài liệu tham khảo không thôi thì chưa đủ. Cái bạn cần là sự hướng dẫn.
        </p>

        <p>
            Vì thế mục đích của tôi là cung cấp một "người hướng dẫn" cho bạn.
        </p>

        <a name="a-word-of-warning"></a>

        <h3>Vài lời nhắc nhở</h3>

        <p>
            Có rất nhiều lập trình viên JavaScript tuyệt vời ngoài kia. Tôi không phải một trong số họ.
        </p>

        <p>
            Tôi thực sự chỉ là người vừa được đề cập tới ở đoạn trước. Tôi biết một hoặc hai "tí" về phát triển ứng dụng web ở phía backend, JavaScript "thực thụ" vẫn còn là mới mẻ đối với tôi, cả Node.js cũng vậy. Tôi mới chỉ học được một vài khía cạnh nâng cao của JavaScript gần đây. Tôi không phải là "kẻ lão luyện".
        </p>

        <p>
            Đó cũng là lý do vì sao đây không phải là cuốn sách để biến bạn "từ lính mới thành chuyên gia". Nó giống như "từ lính mới trở thành lính mới cao cấp" hơn.
        </p>

        <p>
            Nếu không nhầm thì đây là thứ mà tôi đã muốn có khi bắt đầu tìm hiểu về Node.js.
        </p>

        <a name="server-side-javascript"></a>

        <h3>Server-side JavaScript</h3>

        <p>
            Những hiện thân đầu tiên của JavaScript tồn tại trên trình duyệt. Nhưng đây chỉ là cái ngữ cảnh mà thôi. Nó vạch rõ những cái bạn có thể làm với JavaScript chứ không đề cập nhiều tới những cái mà bản thân JavaScript có thể làm. JavaScript là một ngôn ngữ "trọn vẹn": bạn có thể sử dụng nó ở nhiều ngữ cảnh và đạt được mọi thứ giống như với bất kỳ ngôn ngữ "trọn vẹn" nào khác.
        </p>

        <p>
            Node.js thực tế chỉ là một ngữ cảnh khác: nó cho phép bạn chạy mã JavaScript ở phía backend, vượt ra khỏi phạm vi trình duyệt.
        </p>

        <p>
            Để chạy được JavaScript phía backend, mã nguồn cần phải được biên dịch, và, chạy. Đây chính là những gì mà Node.js đảm nhiệm, bằng việc sử dụng lại máy ảo V8 của Google, nó chính là môi trường chạy của JavaScript được sử dụng trên Google Chrome.
        </p>

        <p>
            Thêm vào đó, Node.js còn cung cấp rất nhiều phần bổ sung (module) hữu ích, chính vì vậy bạn sẽ không phải viết ứng dụng của bạn từ đầu, ví dụ đơn giản như hiển thị một dòng chữ nào đó cho người dùng.
        </p>

        <p>
            Chính vì thế, Node.js bao gồm 2 trong 1: một môi trường chạy (runtime environment) và một thư viện.
        </p>

        <p>
            Để có thể tận dụng được hết những tính năng này, bạn cần phải cài đặt Node.js. Thay vì lặp lại các bước hướng dẫn cài đặt ở đây, bạn vui lòng hãy làm theo 
            <a href="https://github.com/joyent/node/wiki/Installation" title="Building and Installing Node.js">hướng dẫn cài đặt chính thức tại đây</a>. Sau đó trở lại đây khi đã hoàn tất.
        </p>

        <a name="hello-world"></a>

        <h3>"Hello World"</h3>

        <p>
            Ok, hãy cùng bắt tay vào viết ứng dụng sử dụng Node.js đầu tiên của chúng ta: "Hello World".
        </p>

        <p>
            Hãy mở chương trình biên tập (editor) yêu thích của bạn ra và tạo một file mới có tên là <em>helloworld.js</em>. Chúng ta muốn in "Hello World"
            ra STDOUT, và đây là tất cả những gì chúng ta cần:
        </p>
        <pre class="prettyprint lang-js"><span class="pln">console</span><span class="pun">.</span><span
                class="pln">log</span><span class="pun">(</span><span class="str">"Hello World"</span><span class="pun">);</span></pre>
        <p>
            Lưu file lại và chạy nó thông qua Node.js:
        </p>

        <pre>node helloworld.js</pre>
        <p>
            Chương trình sẽ in <em>Hello World</em> ra màn hình terminal hoặc command prompt của bạn.
        </p>

        <p>
            Hơi buồn tẻ một chút phải không? Hãy cùng làm cái gì đó thực tế hơn.
        </p>


        <a name="a-full-blown-web-application-with-nodejs"></a>

        <h2>Một ứng dụng web hoàn chính với Node.js</h2>

        <a name="the-use-cases"></a>

        <h3>The use cases</h3>

        <p>
            Đơn giản thôi, nhưng thực tế:
        </p>
        <ul>

            <li>
                Người dùng có thể dùng được ứng dụng của chúng ta trên một trình duyệt bất kỳ.
            </li>
            <li>
                Người dùng sẽ nhìn thấy một trang chào đón có hiển thị một form để tải file lên khi truy cập vào địa chỉ http://<em>domain</em>/start
            </li>
            <li>
                Sau khi chọn một bức ảnh và ấn gửi đi, bức ảnh đó sẽ được gửi đến http://<em>domain</em>/upload, nơi nó sẽ được hiển thị sau khi quá trình tải lên hoàn tất.
            </li>

        </ul>
        <p>
            Thế là đủ rồi. Bây giờ, bạn có thể đạt được mục tiêu này bằng cách google và sửa code của một <em>ai đó</em>. Nhưng đó không phải là cách mà chúng ta làm ở đây.
        </p>

        <p>
            Hơn nữa, chúng ta không muốn chỉ viết code đơn giản nhất có thể để "miễn sao xong là được", cái chúng ta muốn ở đây là chính xác và rõ ràng nhất có thể. Chúng ta sẽ sử dụng nhiều sự trừu tượng hoá hơn mức bình thường nhằm mục đích làm quen với các ứng dụng Node.js phức tạp hơn.
        </p>

        <a name="the-application-stack"></a>

        <h3>Cấu trúc của ứng dụng</h3>

        <p>
            Hãy cùng chia nhỏ ứng dụng của chúng ta ra để xem phần nào cần được thực hiện để có thể đạt được mục tiêu đã đề ra (use cases).
        </p>

        <ul>
            <li>
                Chúng ta muốn cung cấp các trang web, vì thế chúng ta cần một
                <strong>máy chủ HTTP</strong>
            </li>

            <li>
                Máy chủ của chúng ta phải phản hồi/trả lời được các yêu cầu khác nhau, phụ thuộc vào địa chỉ (URL) nào được gửi lên, vì thể chúng ta cần cái gì đó giống như <strong>router</strong> (cầu nối/dẫn) để ánh xạ các yêu cầu đến nơi chuyên xử lý các yêu cầu (request handler) đó.
            </li>
            <li>
                Để đáp ứng các yêu cầu nhận được ở phía máy chủ mà đã được dẫn hướng thông qua router, chúng ta cần các <strong>request handlers</strong> thật sự.
            </li>
            <li>
                Chắc chắn router của chúng ta sẽ xử lý tất cả các dữ liệu được gửi đến qua phương thức POST và gửi nó dưới một định dạng thuận tiện đến các request handlers, vì thế chúng ta cần <strong>request data handling</strong>. (Đây là bước xử lý &nbsp; format dữ liệu).
            </li>
            <li>
                Chúng ta không chỉ muốn xử lý các yêu cầu cho các địa chỉ (URLs) mà còn hiển thị nội dung khi những địa chỉ này được yêu cầu, điều này có nghĩa chúng ta cần một loại <strong>view logic</strong> mà request handlers có thể sử dụng để gửi nội dung về trình duyệt của người dùng.
            </li>
            <li>
                Cuối cùng, người dùng có thể tải ảnh, vì thể chúng ta cần một loại <strong>upload handling</strong> để xử lý việc upload.
            </li>
        </ul>

        <p>
            Hãy dành một chút thời gian để nghĩ xem chúng ta sẽ xây dựng cấu trúc này với PHP như thế nào. Đó không hẳn là một bí mật, thiết lập đặc trưng sẽ là máy chủ Apache với mod_php5.
            <br>
            Điều này đồng nghĩa với việc nhận, gửi và xử lý các yêu cầu không hề xảy ra trong chính bản thân PHP.
        </p>

        <p>
            Với node, mọi thứ có một chút khác biệt. Bởi vì chúng ta không chỉ viết ứng dụng, mà còn cả máy chủ HTTP. Thực tế, ứng dụng web của chúng ta và máy chủ web của nó về cơ bản là giống nhau.
        </p>

        <p>
            Có vẻ như có rất nhiều việc để làm, nhưng bạn sẽ thấy trong một lát nữa, với Node.js nó không phải như vậy.
        </p>

        <p>
            Cùng bắt đầu từ vạch xuất phát và viết phần đầu tiên trong cấu trúc của ứng dụng của chúng ta, máy chủ HTTP.
        </p>

        <a name="building-the-application-stack"></a>

        <h2>Xây dựng cấu trúc ứng dụng</h2>

        <a name="a-basic-http-server"></a>

        <h3>Một máy chủ HTTP cơ bản</h3>

        <p>
            Ở cái thời điểm mà tôi muốn bắt đầu phát triển ứng dụng Node.js có tính thực tiễn đầu tiên của tôi, tôi không chỉ băn khoăn xem phát triển nó như thế nào mà còn tổ chức nó ra làm sao.
            <br>
            Tôi có nên viết tất cả vào trong một file? Đa số các hướng dẫn viết một máy chủ HTTP sử dung Node.js cơ bản đều gộp tất cả vào một chỗ. Vậy nếu tôi muốn đảm bảo rằng code của tôi luôn dễ hiểu khi ứng dụng của tôi ngày một mở rộng lên thì sao?
        </p>

        <p>
            Hiển nhiên, nó tương đối là đơn giản để tổ chức, lưu trữ tách biệt những thứ không có liên quan tới nhau ra, bằng cách cho chúng vào các module khác nhau.
        </p>

        <p>
            Cách này cho phép chúng ta giữ được file chính (file khởi động ứng dụng) và các module luôn rõ ràng, dễ đọc, dễ bảo trì và các module còn có thể được sử dụng lại ở nhiều nơi khác nhau.
        </p>

        <p>
            Bây giờ hãy tạo một file chính, nơi khởi chạy ứng dụng, và một file module nơi chứa mã nguồn cho máy chủ HTTP.
        </p>

        <p>
            Theo quan điểm cá nhân của tôi, quy chuẩn để đặt tên file chính là <em>index.js</em> sẽ khiến việc đặt tên module máy chủ <em>server.js</em> trở nên hợp lý và logic hơn.
        </p>

        <p>
            Hãy cùng bắt đầu viết module cho máy chủ. Tạo mới file <em>server.js</em> trong thư mục gốc project của bạn, và viết vào đoạn code sau:
        </p>
        <pre class="prettyprint lang-js"><span class="kwd">var</span><span class="pln"> http </span><span
                class="pun">=</span><span class="pln"> require</span><span class="pun">(</span><span
                class="str">"http"</span><span class="pun">);</span><span class="pln"><br><br>http</span><span
                class="pun">.</span><span class="pln">createServer</span><span class="pun">(</span><span class="kwd">function</span><span
                class="pun">(</span><span class="pln">request</span><span class="pun">,</span><span class="pln"> response</span><span
                class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; response</span><span
                class="pun">.</span><span class="pln">writeHead</span><span class="pun">(</span><span
                class="lit">200</span><span class="pun">,</span><span class="pln"> </span><span
                class="pun">{</span><span class="str">"Content-Type"</span><span class="pun">:</span><span
                class="pln"> </span><span class="str">"text/plain"</span><span class="pun">});</span><span
                class="pln"><br>&nbsp; response</span><span class="pun">.</span><span class="pln">write</span><span
                class="pun">(</span><span class="str">"Hello World"</span><span class="pun">);</span><span
                class="pln"><br>&nbsp; response</span><span class="pun">.</span><span class="pln">end</span><span
                class="pun">();</span><span class="pln"><br></span><span class="pun">}).</span><span
                class="pln">listen</span><span class="pun">(</span><span class="lit">8888</span><span
                class="pun">);</span></pre>

        <p>
            Chỉ thế thôi! Bạn vừa viết xong một máy chủ HTTP có khả năng hoạt động tốt. Hãy xác thực lại việc đó bằng cách chạy và kiểm tra nó. Đầu tiên, hãy chạy lệnh sau bằng Node.js:
        </p>
        <pre>node server.js</pre>
        <p>
            Bây giờ hãy mở trình duyệt của bạn ra và truy cập vào địa chỉ sau <a href="http://localhost:8888/" rel="nofollow">http://localhost:8888/</a>. Nếu đúng như mong đợi, những gì chúng ta thấy sẽ là "Hello World".
        </p>

        <p>
            Thú vị phải không? Bạn nghĩ sao về việc cùng tìm hiểu xem nó hoạt động như thế nào? Hãy tạm thời để câu hỏi làm thế nào để tổ chức dự án của chúng ta lại đó. Tôi hứa sẽ đề cập lại tới nó trong những phần tiếp theo.
        </p>

        <a name="analyzing-our-http-server"></a>

        <h3>Phân tích máy chủ HTTP</h3>

        <p>
            Chúng ta hãy cùng phân tích xem nó hoạt động như thế nào.
        </p>

        <p>
            Dòng đầu tiên <em>khai báo</em> (chính xác hơn là yêu cầu, giống với import và using) rằng chúng ta sẽ sử dụng module <em>http</em> có sẵn trong Node.js vào trong ứng dụng và sẽ gọi đến nó thông qua biến có tên <em>http</em>.
        </p>

        <p>
            Tiếp đến chúng ta sẽ gọi một trong các hàm có sẵn của module http: <em>createServer</em>. Hàm này sẽ trả về một đối tượng, đối tượng này chứa một hàm/phương thức khác gọi là <em>listen</em>, hàm này nhận giá trị truyền vào bằng số và sử dụng nó làm cổng để lắng nghe các request từ phía client.
        </p>

        <p>
            Bạn đừng để ý gì tới cái hàm được khai báo sau dấu mở ngoặc của hàm <em>http.createServer</em> vội.
        </p>

        <p>
            Chúng ta đã có thể viết code để khởi động máy chủ của chúng ta ở cổng 8888 như sau:
        </p>
        <pre class="prettyprint lang-js"><span class="kwd">var</span><span class="pln"> http </span><span
                class="pun">=</span><span class="pln"> require</span><span class="pun">(</span><span
                class="str">"http"</span><span class="pun">);</span><span class="pln"><br><br></span><span class="kwd">var</span><span
                class="pln"> server </span><span class="pun">=</span><span class="pln"> http</span><span
                class="pun">.</span><span class="pln">createServer</span><span class="pun">();</span><span
                class="pln"><br>server</span><span class="pun">.</span><span class="pln">listen</span><span class="pun">(</span><span
                class="lit">8888</span><span class="pun">);</span></pre>

        <p>
            Đoạn code này sẽ khởi động một máy chủ HTTP, lắng nghe ở cổng 8888 nhưng không làm gì cả (thậm chí không hề trả lời các yêu cầu được gửi tới).
        </p>

        <p>
            Điều thực sự thú vị (nhìn nó hơi buồn cười nếu như bạn đã biết về PHP) ở đây chính là phần định nghĩa của cái hàm được sử dụng như là giá trị truyền vào cho hàm <em>createServer()</em> kia.
        </p>

        <p>
            Hoá ra, định nghĩa hàm kia lại chính là giá trị đầu tiên (và duy nhất) mà chúng ta truyền cho lời gọi hàm <em>createServer()</em>. Bởi vì trong JavaScript, hàm có thể được sử dụng như là biến truyền vào cho các hàm.
        </p>

        <a name="passing-functions-around"></a>

        <h3>Sử dụng hàm như biến</h3>

        <p>
            Ví dụ, bạn có thể viết như sau:
        </p>
        <pre class="prettyprint lang-js"><span class="kwd">function</span><span class="pln"> say</span><span
                class="pun">(</span><span class="pln">word</span><span class="pun">)</span><span
                class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; console</span><span
                class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span
                class="pln">word</span><span class="pun">);</span><span class="pln"><br></span><span
                class="pun">}</span><span class="pln"><br><br></span><span class="kwd">function</span><span class="pln"> execute</span><span
                class="pun">(</span><span class="pln">someFunction</span><span class="pun">,</span><span class="pln"> value</span><span
                class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; someFunction</span><span
                class="pun">(</span><span class="pln">value</span><span class="pun">);</span><span
                class="pln"><br></span><span class="pun">}</span><span class="pln"><br><br>execute</span><span
                class="pun">(</span><span class="pln">say</span><span class="pun">,</span><span
                class="pln"> </span><span class="str">"Hello"</span><span class="pun">);</span></pre>

        <p>
            Hãy đọc thật kĩ! Cái chúng ta viết ở đây là, hàm <em>say</em> được sử dụng như là biến đầu vào cho hàm <em>execute</em>. Không phải giá trị trả về của <em>say</em>, mà chính bản thân nó!
        </p>

        <p>
            Vì thế, <em>say</em> trở thành biến nội bộ <em>someFunction</em> trong hàm <em>execute</em>, và <em>execute</em> có thể gọi bất kỳ hàm nào trong biến <em>someFunction</em> bằng việc gọi đến hàm (biến) đó (bằng cách thêm dấu ngoặc).
        </p>

        <p>
            Tất nhiên, vì <em>say</em> nhận một biến truyền vào, <em>execute</em> cũng có thể truyền một biến tương tự như thế khi gọi hàm <em>someFunction</em>.
        </p>

        <p>
            We can, as we just did, pass a function as a parameter to
            another function by its name. But we don't have to take this
            indirection of first defining, then passing it - we can
            define and pass a function as a parameter to another
            function in-place:
        </p>
        <pre class="prettyprint lang-js"><span class="kwd">function</span><span class="pln"> execute</span><span
                class="pun">(</span><span class="pln">someFunction</span><span class="pun">,</span><span class="pln"> value</span><span
                class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; someFunction</span><span
                class="pun">(</span><span class="pln">value</span><span class="pun">);</span><span
                class="pln"><br></span><span class="pun">}</span><span class="pln"><br><br>execute</span><span
                class="pun">(</span><span class="kwd">function</span><span class="pun">(</span><span
                class="pln">word</span><span class="pun">){</span><span class="pln"> console</span><span
                class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span
                class="pln">word</span><span class="pun">)</span><span class="pln"> </span><span
                class="pun">},</span><span class="pln"> </span><span class="str">"Hello"</span><span
                class="pun">);</span></pre>

        <p>
            We define the function we want to pass to <em>execute</em>
            right there at the place where <em>execute</em> expects its
            first parameter.
        </p>

        <p>
            This way, we don't even need to give the function a name,
            which is why this is called an <em>anonymous function</em>.
        </p>

        <p>
            This is a first glimpse at what I like to call "advanced"
            JavaScript, but let's take it step by step. For now, let's
            just accept that in JavaScript, we can pass a function as
            a parameter when calling another function. We can do this
            by assigning our function to a variable, which we then
            pass, or by defining the function to pass in-place.
        </p>

        <a name="how-function-passing-makes-our-http-server-work"></a>

        <h3>How function passing makes our HTTP server work</h3>

        <p>
            With this knowledge, let's get back to our minimalistic
            HTTP server:
        </p>
        <pre class="prettyprint lang-js"><span class="kwd">var</span><span class="pln"> http </span><span
                class="pun">=</span><span class="pln"> require</span><span class="pun">(</span><span
                class="str">"http"</span><span class="pun">);</span><span class="pln"><br><br>http</span><span
                class="pun">.</span><span class="pln">createServer</span><span class="pun">(</span><span class="kwd">function</span><span
                class="pun">(</span><span class="pln">request</span><span class="pun">,</span><span class="pln"> response</span><span
                class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; response</span><span
                class="pun">.</span><span class="pln">writeHead</span><span class="pun">(</span><span
                class="lit">200</span><span class="pun">,</span><span class="pln"> </span><span
                class="pun">{</span><span class="str">"Content-Type"</span><span class="pun">:</span><span
                class="pln"> </span><span class="str">"text/plain"</span><span class="pun">});</span><span
                class="pln"><br>&nbsp; response</span><span class="pun">.</span><span class="pln">write</span><span
                class="pun">(</span><span class="str">"Hello World"</span><span class="pun">);</span><span
                class="pln"><br>&nbsp; response</span><span class="pun">.</span><span class="pln">end</span><span
                class="pun">();</span><span class="pln"><br></span><span class="pun">}).</span><span
                class="pln">listen</span><span class="pun">(</span><span class="lit">8888</span><span
                class="pun">);</span></pre>

        <p>
            By now it should be clear what we are actually doing here:
            we pass the <em>createServer</em> function an anonymous
            function.
        </p>

        <p>
            We could achieve the same by refactoring our code to:
        </p>
        <pre class="prettyprint lang-js"><span class="kwd">var</span><span class="pln"> http </span><span
                class="pun">=</span><span class="pln"> require</span><span class="pun">(</span><span
                class="str">"http"</span><span class="pun">);</span><span class="pln"><br><br></span><span class="kwd">function</span><span
                class="pln"> onRequest</span><span class="pun">(</span><span class="pln">request</span><span
                class="pun">,</span><span class="pln"> response</span><span class="pun">)</span><span
                class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; response</span><span
                class="pun">.</span><span class="pln">writeHead</span><span class="pun">(</span><span
                class="lit">200</span><span class="pun">,</span><span class="pln"> </span><span
                class="pun">{</span><span class="str">"Content-Type"</span><span class="pun">:</span><span
                class="pln"> </span><span class="str">"text/plain"</span><span class="pun">});</span><span
                class="pln"><br>&nbsp; response</span><span class="pun">.</span><span class="pln">write</span><span
                class="pun">(</span><span class="str">"Hello World"</span><span class="pun">);</span><span
                class="pln"><br>&nbsp; response</span><span class="pun">.</span><span class="pln">end</span><span
                class="pun">();</span><span class="pln"><br></span><span class="pun">}</span><span class="pln"><br><br>http</span><span
                class="pun">.</span><span class="pln">createServer</span><span class="pun">(</span><span class="pln">onRequest</span><span
                class="pun">).</span><span class="pln">listen</span><span class="pun">(</span><span
                class="lit">8888</span><span class="pun">);</span></pre>

        <p>
            Maybe now is a good moment to ask: Why are we doing it
            that way?
        </p>

        <a name="event-driven-callbacks"></a>

        <h3>Event-driven asynchronous callbacks</h3>

        <p>
            To understand why Node.js applications have to be written this way,
            we need to understand how Node.js executes our code. Node's
            approach isn't unique, but the underlying execution model is
            different from runtime environments like Python, Ruby, PHP or Java.
        </p>

        <p>
            Let's take a very simple piece of code like this:
        </p>

        <pre class="prettyprint lang-js">var result = database.query("SELECT * FROM hugetable");
console.log("Hello World");</pre>

        <p>
            Please ignore for now that we haven't actually talked about
            connecting to databases before - it's just an example. The
            first line queries a database for lots of rows, the second
            line puts "Hello World" to the console.
        </p>

        <p>
            Let's assume that the database query is really slow, that it has
            to read an awful lot of rows, which takes several seconds.
        </p>

        <p>
            The way we have written this code, the JavaScript interpreter of
            Node.js first has to read the complete result set from the
            database, and then it can execute the <em>console.log()</em>
            function.
        </p>

        <p>
            If this piece of code actually was, say, PHP, it would work the
            same way: read all the results at once, then execute the next line
            of code. If this code would be part of a web page script, the user
            would have to wait several seconds for the page to load.
        </p>

        <p>
            However, in the execution model of PHP, this would not become a
            "global" problem: the web server starts its own PHP process for
            every HTTP request it receives. If one of these requests results
            in the execution of a slow piece of code, it results in a slow
            page load for this particular user, but other users requesting
            other pages would not be affected.
        </p>

        <p>
            The execution model of Node.js is different - there is only one
            single process. If there is a slow database query somewhere in
            this process, this affects the whole process - everything comes
            to a halt until the slow query has finished.
        </p>

        <p>
            To avoid this, JavaScript, and therefore Node.js, introduces the
            concept of event-driven, asynchronous callbacks, by utilizing an
            event loop.
        </p>

        <p>
            We can understand this concept by analyzing a rewritten version
            of our problematic code:
        </p>

        <pre class="prettyprint lang-js">database.query("SELECT * FROM hugetable", function(rows) {
  var result = rows;
});
console.log("Hello World");</pre>

        <p>
            Here, instead of expecting <em>database.query()</em> to directly
            return a result to us, we pass it a second parameter, an anonymous
            function.
        </p>

        <p>
            In its previous form, our code was synchronous: <em>first</em>
            do the database query, and only when this is done, <em>then</em>
            write to the console.
        </p>

        <p>
            Now, Node.js can handle the database request asynchronously.
            Provided that <em>database.query()</em> is part of an asynchronous
            library, this is what Node.js does: just as before, it takes the
            query and sends it to the database. But instead of waiting for it
            to be finished, it makes a mental note that says "When at some
            point in the future the database server is done and sends the
            result of the query, then I have to execute the anonymous function
            that was passed to <em>database.query()</em>."
        </p>

        <p>
            Then, it immediately executes <em>console.log()</em>, and
            afterwards, it enters the event loop. Node.js continuously cycles
            through this loop again and again whenever there is nothing else
            to do, waiting for events. Events like, e.g., a slow database
            query finally delivering its results.
        </p>

        <p>
            This also explains why our HTTP server needs a function it can
            call upon incoming requests - if Node.js would start the server
            and then just pause, waiting for the next request, continuing
            only when it arrives, that would be highly inefficent. If a second
            user requests the server while it is still serving the first
            request, that second request could only be answered after the first
            one is done - as soon as you have more than a handful of HTTP
            requests per second, this wouldn't work at all.
        </p>

        <p>
            It's important to note that this asynchronous, single-threaded,
            event-driven execution model isn't an infinitely scalable
            performance unicorn with silver bullets attached. It is just one
            of several models, and it has its limitations, one being that as
            of now, Node.js is just one single process, and it can run on only
            one single CPU core. Personally, I find this model quite
            approachable, because it allows to write applications that have to
            deal with concurrency in an efficient and relatively
            straightforward manner.
        </p>

        <p>
            You might want to take the time to read Felix
            Geisendörfer's excellent post
            <a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb">Understanding
                node.js</a>
            for additional background explanation.
        </p>

        <p>
            Let's play around a bit with this new concept. Can we prove
            that our code continues after creating the server, even if
            no HTTP request happened and the callback function we
            passed isn't called? Let's try it:
        </p>
        <pre class="prettyprint lang-js"><span class="kwd">var</span><span class="pln"> http </span><span
                class="pun">=</span><span class="pln"> require</span><span class="pun">(</span><span
                class="str">"http"</span><span class="pun">);</span><span class="pln"><br><br></span><span class="kwd">function</span><span
                class="pln"> onRequest</span><span class="pun">(</span><span class="pln">request</span><span
                class="pun">,</span><span class="pln"> response</span><span class="pun">)</span><span
                class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; console</span><span
                class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">"Request received."</span><span
                class="pun">);</span><span class="pln"><br>&nbsp; response</span><span class="pun">.</span><span
                class="pln">writeHead</span><span class="pun">(</span><span class="lit">200</span><span
                class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span
                class="str">"Content-Type"</span><span class="pun">:</span><span class="pln"> </span><span class="str">"text/plain"</span><span
                class="pun">});</span><span class="pln"><br>&nbsp; response</span><span class="pun">.</span><span
                class="pln">write</span><span class="pun">(</span><span class="str">"Hello World"</span><span
                class="pun">);</span><span class="pln"><br>&nbsp; response</span><span class="pun">.</span><span
                class="pln">end</span><span class="pun">();</span><span class="pln"><br></span><span
                class="pun">}</span><span class="pln"><br><br>http</span><span class="pun">.</span><span class="pln">createServer</span><span
                class="pun">(</span><span class="pln">onRequest</span><span class="pun">).</span><span class="pln">listen</span><span
                class="pun">(</span><span class="lit">8888</span><span class="pun">);</span><span class="pln"><br><br>console</span><span
                class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">"Server has started."</span><span
                class="pun">);</span></pre>

        <p>
            Note that I use <em>console.log</em> to output a text whenever
            the <em>onRequest</em> function (our callback) is triggered,
            and another text right <em>after</em> starting the HTTP server.
        </p>

        <p>
            When we start this (<em>node server.js</em>, as always), it
            will immediately output "Server has started." on the
            command line. Whenever we request our server (by opening
            <a href="http://localhost:8888/" rel="nofollow">http://localhost:8888/</a>

            in our browser), the message "Request received." is printed
            on the command line.
        </p>

        <p>
            Event-driven asynchronous server-side JavaScript with
            callbacks in action :-)
        </p>

        <p>
            (Note that our server will probably write "Request received."
            to STDOUT two times upon opening the page in a browser. That's
            because most browsers will try to load the favicon by requesting
            http://localhost:8888/favicon.ico whenever you open
            http://localhost:8888/).
        </p>

        <a name="how-our-server-handles-requests"></a>

        <h3>How our server handles requests</h3>

        <p>
            Ok, let's quickly analyze the rest of our server code, that
            is, the body of our callback function <em>onRequest()</em>.
        </p>

        <p>
            When the callback fires and our <em>onRequest()</em> function
            gets triggered, two parameters are passed into it:
            <em>request</em> and <em>response</em>.
        </p>

        <p>
            Those are objects, and you can use their methods to handle
            the details of the HTTP request that occured and to respond
            to the request (i.e., to actually send something over
            the wire back to the browser that requested your server).
        </p>

        <p>
            And our code does just that: Whenever a request is
            received, it uses the <em>response.writeHead()</em>
            function to send an HTTP status 200 and content-type in the
            HTTP response header, and the <em>response.write()</em>
            function to send the text "Hello World" in the HTTP
            response body.
        </p>

        <p>
            At last, we call <em>response.end()</em> to actually finish
            our response.
        </p>

        <p>
            At this point, we don't care for the details of the
            request, which is why we don't use the <em>request</em>
            object at all.
        </p>

        <a name="finding-a-place-for-our-server-module"></a>

        <h3>Finding a place for our server module</h3>

        <p>
            Ok, I promised we will get back to how to organize our
            application. We have the code for a very basic HTTP server in
            the file <em>server.js</em>, and I mentioned that it's common
            to have a main file called <em>index.js</em> which is used
            to bootstrap and start our application by making use of the
            other modules of the application (like the HTTP server module
            that lives in <em>server.js</em>).
        </p>

        <p>
            Let's talk about how to make server.js a real Node.js module
            that can be used by our yet-to-be-written <em>index.js</em>
            main file.
        </p>

        <p>
            As you may have noticed, we already used modules in our code,
            like this:
        </p>
        <pre class="prettyprint lang-js"><span class="kwd">var</span><span class="pln"> http </span><span
                class="pun">=</span><span class="pln"> require</span><span class="pun">(</span><span
                class="str">"http"</span><span class="pun">);</span><span class="pln"><br><br></span><span class="pun">...</span><span
                class="pln"><br><br>http</span><span class="pun">.</span><span class="pln">createServer</span><span
                class="pun">(...);</span></pre>

        <p>
            Somewhere within Node.js lives a module called "http", and we can
            make use of it in our own code by requiring it and assigning
            the result of the require to a local variable.
        </p>

        <p>
            This makes our local variable an object that carries all the
            public methods the <em>http</em> module provides.
        </p>

        <p>
            It's common practice to choose the name of the module for the
            name of the local variable, but we are free to choose whatever
            we like:
        </p>
        <pre class="prettyprint lang-js"><span class="kwd">var</span><span class="pln"> foo </span><span
                class="pun">=</span><span class="pln"> require</span><span class="pun">(</span><span
                class="str">"http"</span><span class="pun">);</span><span class="pln"><br><br></span><span class="pun">...</span><span
                class="pln"><br><br>foo</span><span class="pun">.</span><span class="pln">createServer</span><span
                class="pun">(...);</span></pre>

        <p>
            Fine, it's clear how to make use of internal Node.js modules. How
            do we create our own modules, and how do we use them?
        </p>

        <p>
            Let's find out by turning our <em>server.js</em> script into a
            real module.
        </p>

        <p>
            Turns out, we don't have to change that much. Making some code
            a module means we need to <em>export</em> those parts of its
            functionality that we want to provide to scripts that require
            our module.
        </p>

        <p>
            For now, the functionality our HTTP server needs to export is
            simple: scripts requiring our server module simply need to
            start the server.
        </p>

        <p>
            To make this possible, we will put our server code into a
            function named <em>start</em>, and we will export this
            function:
        </p>
        <pre class="prettyprint lang-js"><span class="kwd">var</span><span class="pln"> http </span><span
                class="pun">=</span><span class="pln"> require</span><span class="pun">(</span><span
                class="str">"http"</span><span class="pun">);</span><span class="pln"><br><br></span><span class="kwd">function</span><span
                class="pln"> start</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span
                class="pln"><br>&nbsp; </span><span class="kwd">function</span><span class="pln"> onRequest</span><span
                class="pun">(</span><span class="pln">request</span><span class="pun">,</span><span class="pln"> response</span><span
                class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; console</span><span
                class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">"Request received."</span><span
                class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; response</span><span class="pun">.</span><span
                class="pln">writeHead</span><span class="pun">(</span><span class="lit">200</span><span
                class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span
                class="str">"Content-Type"</span><span class="pun">:</span><span class="pln"> </span><span class="str">"text/plain"</span><span
                class="pun">});</span><span class="pln"><br>&nbsp; &nbsp; response</span><span class="pun">.</span><span
                class="pln">write</span><span class="pun">(</span><span class="str">"Hello World"</span><span
                class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; response</span><span class="pun">.</span><span
                class="pln">end</span><span class="pun">();</span><span class="pln"><br>&nbsp; </span><span class="pun">}</span><span
                class="pln"><br><br>&nbsp; http</span><span class="pun">.</span><span
                class="pln">createServer</span><span class="pun">(</span><span class="pln">onRequest</span><span
                class="pun">).</span><span class="pln">listen</span><span class="pun">(</span><span
                class="lit">8888</span><span class="pun">);</span><span class="pln"><br>&nbsp; console</span><span
                class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">"Server has started."</span><span
                class="pun">);</span><span class="pln"><br></span><span class="pun">}</span><span class="pln"><br><br>exports</span><span
                class="pun">.</span><span class="pln">start </span><span class="pun">=</span><span
                class="pln"> start</span><span class="pun">;</span></pre>

        <p>
            This way, we can now create our main file <em>index.js</em>,
            and start our HTTP there, although the code for the server is
            still in our <em>server.js</em> file.
        </p>

        <p>
            Create a file <em>index.js</em> with the following content:
        </p>
        <pre class="prettyprint lang-js"><span class="kwd">var</span><span class="pln"> server </span><span class="pun">=</span><span
                class="pln"> require</span><span class="pun">(</span><span class="str">"./server"</span><span
                class="pun">);</span><span class="pln"><br><br>server</span><span class="pun">.</span><span class="pln">start</span><span
                class="pun">();</span></pre>

        <p>
            As you can see, we can use our server module just like any
            internal module: by requiring its file and assigning it to
            a variable, its exported functions become available to us.
        </p>

        <p>
            That's it. We can now start our app via our main script, and it
            still does exactly the same:
        </p>
        <pre>node index.js</pre>

        <p>
            Great, we now can put the different parts of our application
            into different files and wire them together by making them
            modules.
        </p>

        <p>
            We still have only the very first part of our application in
            place: we can receive HTTP requests. But we need to do
            something with them - depending on which URL the browser
            requested from our server, we need to react differently.
        </p>

        <p>
            For a very simple application, you could do this directly
            within the callback function <em>onRequest()</em>. But as I said,
            let's add a bit more abstraction in order to make our example
            application a bit more interesting.
        </p>

        <p>
            Making different HTTP requests point at different parts of our
            code is called "routing" - well, then, let's create a module
            called <em>router</em>.
        </p>

        <a name="whats-needed-to-route-requests"></a>

        <h3>What's needed to "route" requests?</h3>

        <p>
            We need to be able to feed the requested URL and possible
            additional GET and POST parameters into our router, and based
            on these the router then needs to be able to decide which code
            to execute (this "code to execute" is the third part of our
            application: a collection of request handlers that do the
            actual work when a request is received).
        </p>

        <p>
            So, we need to look into the HTTP requests and extract the
            requested URL as well as the GET/POST parameters from them.
            It could be argued if that should be part of the router or
            part of the server (or even a module of its own), but let's
            just agree on making it part of our HTTP server for now.
        </p>

        <p>
            All the information we need is available through the
            <em>request</em> object which is passed as the first parameter
            to our callback function <em>onRequest()</em>. But to interpret
            this information, we need some additional Node.js modules, namely
            <em>url</em> and <em>querystring</em>.
        </p>

        <a name="head20"></a>
        <p>
            The <em>url</em> module provides methods which allow us to
            extract the different parts of a URL (like e.g. the requested
            path and query string), and <em>querystring</em> can in turn be
            used to parse the query string for request parameters:
        </p>
<pre>                               url.parse(string).query
                                           |
           url.parse(string).pathname      |
                       |                   |
                       |                   |
                     ------ -------------------
http://localhost:8888/start?foo=bar&amp;hello=world
                                ---       -----
                                 |          |
                                 |          |
              querystring(string)["foo"]    |
                                            |
                         querystring(string)["hello"]
</pre>

        <p>
            We can, of course, also use <em>querystring</em> to parse the
            body of a POST request for parameters, as we will see
            later.
        </p>

        <p>
            Let's now add to our <em>onRequest()</em> function the logic
            needed to find out which URL path the browser requested:
        </p>
        <pre class="prettyprint lang-js"><span class="kwd">var</span><span class="pln"> http </span><span
                class="pun">=</span><span class="pln"> require</span><span class="pun">(</span><span
                class="str">"http"</span><span class="pun">);</span><span class="pln"><br></span><span
                class="kwd">var</span><span class="pln"> url </span><span class="pun">=</span><span
                class="pln"> require</span><span class="pun">(</span><span class="str">"url"</span><span
                class="pun">);</span><span class="pln"><br><br></span><span class="kwd">function</span><span
                class="pln"> start</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span
                class="pln"><br>&nbsp; </span><span class="kwd">function</span><span class="pln"> onRequest</span><span
                class="pun">(</span><span class="pln">request</span><span class="pun">,</span><span class="pln"> response</span><span
                class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; </span><span
                class="kwd">var</span><span class="pln"> pathname </span><span class="pun">=</span><span class="pln"> url</span><span
                class="pun">.</span><span class="pln">parse</span><span class="pun">(</span><span
                class="pln">request</span><span class="pun">.</span><span class="pln">url</span><span
                class="pun">).</span><span class="pln">pathname</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; console</span><span
                class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">"Request for "</span><span
                class="pln"> </span><span class="pun">+</span><span class="pln"> pathname </span><span
                class="pun">+</span><span class="pln"> </span><span class="str">" received."</span><span
                class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; response</span><span class="pun">.</span><span
                class="pln">writeHead</span><span class="pun">(</span><span class="lit">200</span><span
                class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span
                class="str">"Content-Type"</span><span class="pun">:</span><span class="pln"> </span><span class="str">"text/plain"</span><span
                class="pun">});</span><span class="pln"><br>&nbsp; &nbsp; response</span><span class="pun">.</span><span
                class="pln">write</span><span class="pun">(</span><span class="str">"Hello World"</span><span
                class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; response</span><span class="pun">.</span><span
                class="pln">end</span><span class="pun">();</span><span class="pln"><br>&nbsp; </span><span class="pun">}</span><span
                class="pln"><br><br>&nbsp; http</span><span class="pun">.</span><span
                class="pln">createServer</span><span class="pun">(</span><span class="pln">onRequest</span><span
                class="pun">).</span><span class="pln">listen</span><span class="pun">(</span><span
                class="lit">8888</span><span class="pun">);</span><span class="pln"><br>&nbsp; console</span><span
                class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">"Server has started."</span><span
                class="pun">);</span><span class="pln"><br></span><span class="pun">}</span><span class="pln"><br><br>exports</span><span
                class="pun">.</span><span class="pln">start </span><span class="pun">=</span><span
                class="pln"> start</span><span class="pun">;</span></pre>

        <p>
            Fine. Our application can now distinguish requests based on the
            URL path requested - this allows us to map requests to our
            request handlers based on the URL path using our (yet to be
            written) router.
        </p>

        <p>
            In the context of our application, it simply means that we will
            be able to have requests for the <em>/start</em> and
            <em>/upload</em> URLs handled by different parts of our
            code. We will see how everything fits together soon.
        </p>

        <p>
            Ok, it's time to actually write our router. Create a new file
            called <em>router.js</em>, with the following content:
        </p>
        <pre class="prettyprint lang-js"><span class="kwd">function</span><span class="pln"> route</span><span
                class="pun">(</span><span class="pln">pathname</span><span class="pun">)</span><span
                class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; console</span><span
                class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">"About to route a request for "</span><span
                class="pln"> </span><span class="pun">+</span><span class="pln"> pathname</span><span
                class="pun">);</span><span class="pln"><br></span><span class="pun">}</span><span class="pln"><br><br>exports</span><span
                class="pun">.</span><span class="pln">route </span><span class="pun">=</span><span
                class="pln"> route</span><span class="pun">;</span></pre>

        <p>
            Of course, this code basically does nothing, but that's ok for
            now. Let's first see how to wire together this router with our
            server before putting more logic into the router.
        </p>

        <p>
            Our HTTP server needs to know about and make use of our router.
            We could hard-wire this dependency into the server, but because
            we learned the hard way from our experience with other
            programming languages, we are going to loosely couple server
            and router by injecting this dependency (you may want to read
            <a href="http://martinfowler.com/articles/injection.html">Martin Fowlers excellent post on Dependency Injection</a>
            for background information).
        </p>

        <p>
            Let's first extend our server's <em>start()</em> function in
            order to enable us to pass the route function to be used by
            parameter:
        </p>
        <pre class="prettyprint lang-js"><span class="kwd">var</span><span class="pln"> http </span><span
                class="pun">=</span><span class="pln"> require</span><span class="pun">(</span><span
                class="str">"http"</span><span class="pun">);</span><span class="pln"><br></span><span
                class="kwd">var</span><span class="pln"> url </span><span class="pun">=</span><span
                class="pln"> require</span><span class="pun">(</span><span class="str">"url"</span><span
                class="pun">);</span><span class="pln"><br><br></span><span class="kwd">function</span><span
                class="pln"> start</span><span class="pun">(</span><span class="pln">route</span><span
                class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span
                class="pln"><br>&nbsp; </span><span class="kwd">function</span><span class="pln"> onRequest</span><span
                class="pun">(</span><span class="pln">request</span><span class="pun">,</span><span class="pln"> response</span><span
                class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; </span><span
                class="kwd">var</span><span class="pln"> pathname </span><span class="pun">=</span><span class="pln"> url</span><span
                class="pun">.</span><span class="pln">parse</span><span class="pun">(</span><span
                class="pln">request</span><span class="pun">.</span><span class="pln">url</span><span
                class="pun">).</span><span class="pln">pathname</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; console</span><span
                class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">"Request for "</span><span
                class="pln"> </span><span class="pun">+</span><span class="pln"> pathname </span><span
                class="pun">+</span><span class="pln"> </span><span class="str">" received."</span><span
                class="pun">);</span><span class="pln"><br><br>&nbsp; &nbsp; route</span><span class="pun">(</span><span
                class="pln">pathname</span><span class="pun">);</span><span
                class="pln"><br><br>&nbsp; &nbsp; response</span><span class="pun">.</span><span
                class="pln">writeHead</span><span class="pun">(</span><span class="lit">200</span><span
                class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span
                class="str">"Content-Type"</span><span class="pun">:</span><span class="pln"> </span><span class="str">"text/plain"</span><span
                class="pun">});</span><span class="pln"><br>&nbsp; &nbsp; response</span><span class="pun">.</span><span
                class="pln">write</span><span class="pun">(</span><span class="str">"Hello World"</span><span
                class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; response</span><span class="pun">.</span><span
                class="pln">end</span><span class="pun">();</span><span class="pln"><br>&nbsp; </span><span class="pun">}</span><span
                class="pln"><br><br>&nbsp; http</span><span class="pun">.</span><span
                class="pln">createServer</span><span class="pun">(</span><span class="pln">onRequest</span><span
                class="pun">).</span><span class="pln">listen</span><span class="pun">(</span><span
                class="lit">8888</span><span class="pun">);</span><span class="pln"><br>&nbsp; console</span><span
                class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">"Server has started."</span><span
                class="pun">);</span><span class="pln"><br></span><span class="pun">}</span><span class="pln"><br><br>exports</span><span
                class="pun">.</span><span class="pln">start </span><span class="pun">=</span><span
                class="pln"> start</span><span class="pun">;</span></pre>

        <p>
            And let's extend our <em>index.js</em> accordingly, that is,
            injecting the route function of our router into the server:
        </p>
        <pre class="prettyprint lang-js"><span class="kwd">var</span><span class="pln"> server </span><span class="pun">=</span><span
                class="pln"> require</span><span class="pun">(</span><span class="str">"./server"</span><span
                class="pun">);</span><span class="pln"><br></span><span class="kwd">var</span><span
                class="pln"> router </span><span class="pun">=</span><span class="pln"> require</span><span class="pun">(</span><span
                class="str">"./router"</span><span class="pun">);</span><span class="pln"><br><br>server</span><span
                class="pun">.</span><span class="pln">start</span><span class="pun">(</span><span
                class="pln">router</span><span class="pun">.</span><span class="pln">route</span><span
                class="pun">);</span><span class="pln"><br></span></pre>

        <p>
            Again, we are passing a function, which by now isn't any news
            for us.
        </p>

        <p>
            If we start our application now (<em>node index.js,
            as always</em>), and request an URL, you can now see from the
            application's output that our HTTP server makes use of our
            router and passes it the requested pathname:
        </p>
        <pre>bash$ node index.js
Request for /foo received.
About to route a request for /foo</pre>

        <p>
            (I omitted the rather annoying output for the /favicon.ico
            request).
        </p>

        <a name="execution-in-the-kongdom-of-verbs"></a>

        <h3>Execution in the kingdom of verbs</h3>

        <p>
            May I once again stray away for a while and talk about
            functional programming again?
        </p>

        <p>
            Passing functions is not only a technical consideration.
            With regard to software design, it's almost philosophical.
            Just think about it: in our index file, we could have passed
            the <em>router</em> object into the server, and the server
            could have called this object's <em>route</em> function.
        </p>

        <p>
            This way, we would have passed a <em>thing</em>, and the server
            would have used this thing to <em>do</em> something. Hey,
            router thing, could you please route this for me?
        </p>

        <p>
            But the server doesn't need the thing. It only needs to get
            something <em>done</em>, and to get something done, you don't
            need things at all, you need <em>actions</em>. You don't need
            <em>nouns</em>, you need <em>verbs</em>.
        </p>

        <p>
            Understanding the fundamental mind-shift that's at the core of
            this idea is what made me really understand functional
            programming.
        </p>

        <p>
            And I did understand it when reading Steve Yegge's masterpiece
            <a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">Execution in the Kingdom of Nouns</a>.
            Go read it now, really. It's one of the best writings related
            to software I ever had the pleasure to encounter.
        </p>

        <a name="routing-to-real-request-handlers"></a>

        <h3>Routing to real request handlers</h3>

        <p>
            Back to business. Our HTTP server and our request router are
            now best friends and talk to each other as we intended.
        </p>

        <p>
            Of course, that's not enough. "Routing" means, we want to
            handle requests to different URLs differently. We would like to
            have the "business logic" for requests to <em>/start</em>
            handled in another function than requests to <em>/upload</em>.
        </p>

        <p>
            Right now, the routing "ends" in the router, and the router is
            not the place to actually "do" something with the requests,
            because that wouldn't scale well once our application becomes
            more complex.
        </p>

        <a name="continuereading"></a>
        <p>
            Let's call these functions, where requests are routed to,
            <em>request handlers</em>. And let's tackle those next, because
            unless we have these in place there isn't much sense in doing
            anything with the router for now.
        </p>
        </div>

        <div id="salespitch">
          <div id="bubble">
            <img id="authorimage" src="manuelkiessling.jpg" width="160" height="160"/>
            <p>
              <br/>
              Hi there! Sorry to interrupt you.
            </p>
            <p>
              My name is Manuel Kiessling, I'm the author of this book.
            </p>
            <p>
              If you have read that far, I would like you to consider buying the eBook version
              of this book. It's a beautifully crafted package including a PDF,
              an ePub, and a MOBI file, which means you can read it on all
              kinds of eReaders out there like the Amazon Kindle, the iPad, or
              the Sony Reader, and of course on any PC or Mac.
            </p>
            <p>
              But the best thing about it is that it comes bundled with another
              great Node.js book: <em>"Hands-on Node.js"</em> by Pedro Teixeira. It's a
              complete reference that explains all the Node.js modules in great
              detail - it's perfect to dig deeper once you've finished <em>The Node
              Beginner Book</em>.
            </p>
            <p>
              Both books together would cost a total of $21.98, but we are offering
              it as a bundle for only <strong>$9.99</strong>.
              You can download it immediately, it's
              completely DRM-free, and you will receive any future updates to
              both books for free.
            </p>
            <div class="box">
              <a class="buttonlink" href="buy-bundle/salespitch.html">
                <div class="button">Buy this<br />bundle now</div>
              </a>
              <p></p>
              <a href="buy-bundle/salespitch.html"><img src="the_node_beginner_book_cover_small.png" height="86" width="57" /></a>
              <a href="buy-bundle/salespitch.html"><img src="hands-on_node.js_cover.png" height="86" width="57" /></a>
              <br/>
              <div class="subinfo">
                226 pages in total<br/>
                DRM-free<br/>
                Free updates<br/>
                <strong>Only $9.99</strong>
              </div>
            </div>
          </div>
          <br clear="all"/>
        </div>

        </div>

        <div id="praise">
            <div class="praise">
                <div class="comment">
                    "This is an amazing introduction to Node."
                </div>
                <div class="author">
                    Ryan Dahl, creator of Node.js
                </div>
            </div>
            <div class="praise">
                <div class="comment">
                    "I love nodebeginner.org - concise, direct to the point and
                    even enjoyable to read."
                </div>
                <div class="author">Gojko Adzic, author of <em>Specification by Example</em> and <em>Bridging the Communication Gap</em></div>
            </div>
            <div class="praise">
                <div class="comment">
                    "This is one of the best tutorials I've read.
                    As a former Java coder, I've always found JavaScript
                    to be a black art, but you have really simplified
                    things with this tutorial."
                </div>
                <div class="author">Erskine, from the comments</div>
            </div>
            <div class="praise">
                <div class="comment">
                    "This is one of the few beginner articles I made it all the
                    way through because of how well it's written."
                </div>
                <div class="author">
                    Paul Gibler, from the comments
                </div>
            </div>
            <div class="praise">
                <div class="comment">
                    "Indispensable."
                </div>
                <div class="author">
                    @lecolibrilibre, on Twitter
                </div>
            </div>
            <div class="praise">
                <div class="comment">
                    "I just wanted to drop you a note to say thank you for
                    writing such an excellent introduction to node. Your book's
                    explanation is fantastic, and I can't wait for you to
                    finish it!"
                </div>
                <div class="author">
                    Seth McLaughlin, via eMail
                </div>
            </div>
        </div>

        <div id="disqus_thread"></div>

        <div id="footer">
            <p id="ccimage">
                <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License" border="0" src="creative_commons.png" width="88" height="31"/></a>
            </p>
            <p>
                <span xmlns:dct="http://purl.org/dc/terms/">The Node Beginner Book</span>
                by
                <a xmlns:cc="http://creativecommons.org/ns#" href="http://manuel.kiessling.net" rel="cc:attributionURL">Manuel Kiessling</a> (see <a href="https://plus.google.com/100272082905360445612?rel=author">Google+ profile</a>)
                is licensed under a
                <br />
                <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.
                <br />
                Permissions beyond the scope of this license may be available at <a xmlns:cc="http://creativecommons.org/ns#" href="mailto:manuel@kiessling.net" rel="cc:morePermissions">manuel@kiessling.net</a>.
            </p>
        </div>

        <script type="text/javascript">
            // Google Analytics
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-2127388-6']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();

            // Disqus
            var disqus_shortname = 'nodebeginner';
            var disqus_identifier = 'nodebeginner-book';
            var disqus_url = 'http://www.nodebeginner.org/';
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();

            // CSS browser select
            function css_browser_selector(u){var ua=u.toLowerCase(),is=function(t){return ua.indexOf(t)>-1},g='gecko',w='webkit',s='safari',o='opera',m='mobile',h=document.documentElement,b=[(!(/opera|webtv/i.test(ua))&&/msie\s(\d)/.test(ua))?('ie ie'+RegExp.$1):is('firefox/2')?g+' ff2':is('firefox/3.5')?g+' ff3 ff3_5':is('firefox/3.6')?g+' ff3 ff3_6':is('firefox/3')?g+' ff3':is('gecko/')?g:is('opera')?o+(/version\/(\d+)/.test(ua)?' '+o+RegExp.$1:(/opera(\s|\/)(\d+)/.test(ua)?' '+o+RegExp.$2:'')):is('konqueror')?'konqueror':is('blackberry')?m+' blackberry':is('android')?m+' android':is('chrome')?w+' chrome':is('iron')?w+' iron':is('applewebkit/')?w+' '+s+(/version\/(\d+)/.test(ua)?' '+s+RegExp.$1:''):is('mozilla/')?g:'',is('j2me')?m+' j2me':is('iphone')?m+' iphone':is('ipod')?m+' ipod':is('ipad')?m+' ipad':is('mac')?'mac':is('darwin')?'mac':is('webtv')?'webtv':is('win')?'win'+(is('windows nt 6.0')?' vista':''):is('freebsd')?'freebsd':(is('x11')||is('linux'))?'linux':'','js'];c=b.join(' ');h.className+=' '+c;return c;};css_browser_selector(navigator.userAgent);
        </script>
        <script></script>
    </body>
</html>
